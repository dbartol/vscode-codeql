---
# This file is transformed into the equivalent JSON TextMate grammar, with the following additional
# features available:
#
# The `regexOptions` Property
# A top-level property named `regexOptions` may be defined with a string value. This string
# represents the set of regular expression options to apply to all regular expressions throughout
# the file.
#
# Macros
# The `macros` element defines a map of macro names to replacement text. When a `match`, `begin`, or
# `end` property has a value that is a single-key map, the value is replaced with the value of the
# macro named by the key, with any use of `(?#)` in the macro text replaced with the text of the
# value of the key, surrounded by a non-capturing group (`(?:)`). For example:
#
# The `beginPattern` and `endPattern` Properties
# A rule can have a `beginPattern` or `endPattern` property whose value is a reference to another
# rule (e.g. `#other-rule`). The `beginPattern` property is replaced as follows:
#
# my-rule:
#   beginPattern: '#other-rule'
#
# would be transformed to
#
# my-rule:
#   begin: '(?#other-rule)'
#   beginCaptures:
#     '0':
#       patterns:
#       - include: '#other-rule'
#
# An `endPattern` property is transformed similary.
#
# macros:
#   repeat: '(?#)*'
# repository:
#   multi-letter:
#     match:
#       repeat: '[A-Za-z]'
#     name: scope.multi-letter
# 
# would be transformed to
#
# repository:
#   multi-letter:
#     match: '(?:[A-Za-z])*'
#     name: scope.multi-letter
#
# Reference Expansion
# Any comment of the form `(?#ref-id)` in a `match`, `begin`, or `end` property will be replaced
# with the match text of the rule named "ref-id". If the rule named "ref-id" consists of just a
# `patterns` property with a list of `include` directives, the replacement pattern is the
# disjunction of the match patterns of all of the included rules.

name: QLRA
scopeName: source.qlra
fileTypes: [ra, qlra]
uuid: DAFF8588-F676-4AC5-9CBE-9BC4086B03EF
regexOptions: 'x' # Ignore pattern whitespace

# Macros are parameterized patterns that can be used as a match elsewhere in the file.
# To use a macro, replace the string for a `match`, `begin`, or `end` property with a single-element
# map whose key is the name of the macro to invoke, and whose value is a string to be substituted for
# any usage of `(?#)` in the macro pattern definition.
macros:
  keyword: '\b(?#)(?#end-of-id)'

patterns:
  - include: '#comment'
  - include: '#literal'
  - include: '#instruction-lhs'
  - include: '#instruction-rhs'

repository:
  # A character that can start an identifier
  id-start-char:
    match: '[A-Za-z$_\#@]'

  # A character that can appear in the middle of an identifier
  id-middle-char:
    match: '[A-Za-z0-9$_\#@:.]'

  # A character that can appear at the end of an identifier
  id-end-char:
    match: '[A-Za-z0-9$_\#@]'

  # An identifier
  id:
    match: '(?#id-start-char)(?:(?#id-middle-char)*(?#id-end-char))'

  natural-number:
    match: '[0-9]+'

  bracket-comment:
    begin: '\[\[\['
    beginCaptures:
      '0':
        name: punctuation.definition.comment.qlra
    end: ']]]|$'
    endCaptures:
      '0':
        name: punctuation.definition.comment.qlra
    name: comment.block.qlra

  slash-star-comment:
    begin: '/\*'
    beginCaptures:
      '0':
        name: punctuation.definition.comment.qlra
    end: '\*/'
    endCaptures:
      '0':
        name: punctuation.definition.comment.qlra
    name: comment.block.qlra

  line-comment:
    begin: '//'
    beginCaptures:
      '0':
        name: punctuation.definition.comment.qlra
    end: '$'
    name: comment.line.double-slash.qlra

  comment:
    patterns:
    - include: '#bracket-comment'
    - include: '#slash-star-comment'
    - include: '#line-comment'

  # Literals
  integer-literal:
    match: '(?:\+ | -)?(?#natural-number)'
    name: constant.numeric.decimal.qlra

  string-literal:
    begin: '"'
    beginCaptures:
      '0':
        name: punctuation.definition.string.begin.qlra
    end: '"|$' # Guard against unterminated strings
    endCaptures:
      '0':
        name: punctuation.definition.string.end.qlra
    name: string.quoted.double.qlra
    patterns:
      - match: '\\.'
        name: constant.character.escape.qlra

  literal:
    patterns:
    - include: '#integer-literal'
    - include: '#string-literal'

  # Operators and punctuation
  open-brace:
    match: '\{'
    name: punctuation.curlybrace.open.ql

  close-brace:
    match: '\}'
    name: punctuation.curlybrace.close.ql

  open-bracket:
    match: '\['
    name: punctuation.squarebracket.open.qlra

  close-bracket:
    match: '\]'
    name: punctuation.squarebracket.close.qlra

  open-paren:
    match: '\('
    name: punctuation.parenthesis.open.qlra

  close-paren:
    match: '\)'
    name: punctuation.parenthesis.close.qlra

  arithmetic-operator:
    match: '\+ | - | \* | / | %'
    name: keyword.operator.arithmetic.qlra

  colon:
    match: ':'
    name: punctuation.separator.colon.qlra
  
  coloncolon:
    match: '::'
    name: punctuation.separator.coloncolon.qlra
  
  comma:
    match: ','
    name: punctuation.separator.comma.qlra
  
  concatenation:
    match: '\+\+'
    name: keyword.operator.arithmetic.qlra

  define:
    match: ':-'
    name: punctuation.separator.define.qlra

  dot:
    match: '\.'
    name: punctuation.separator.dot.qlra

  equals:
    match: '='
    name: punctuation.separator.equals.qlra

  hash:
    match: '\#'
    name: punctuation.separator.hash.qlra

  relational-operator:
    match: '<= | < | >= | >'
    name: keyword.operator.relational.qlra

  semicolon:
    match: ';'
    name: punctuation.separator.statement.qlra
  
  stage-end:
    match: '========'
    name: punctuation.separator.stage-end.qlra

  union:
    match: '\\/'
    name: punctuation.operator.union.qlra

  operator-or-punctuation:
    patterns:
    - include: '#coloncolon' # Must precede colon
    - include: '#concatenation' # Must precede arithmetic-operator
    - include: '#define' # Must precede colon
    - include: '#stage-end' # Must precede equals
    - include: '#open-brace'
    - include: '#close-brace'
    - include: '#open-bracket'
    - include: '#close-bracket'
    - include: '#open-paren'
    - include: '#close-paren'
    - include: '#arithmetic-operator'
    - include: '#colon'
    - include: '#comma'
    - include: '#dot'
    - include: '#equals'
#    - include: '#hash'
    - include: '#relational-operator'
    - include: '#semicolon'
    - include: '#union'

# Relation annotation keywords
  cached:
    match:
      keyword: 'CACHED'
    name: storage.modifier.cached.qlra
  
  computed:
    match:
      keyword: 'COMPUTED'
    name: storage.modifier.computed.qlra

  synthetic:
    match:
      keyword: 'SYNTHETIC'
    name: storage.modifier.synthetic.qlra

  relation-annotation-keyword:
    patterns:
    - include: '#cached'
    - include: '#computed'
    - include: '#synthetic'

# Type annotation keywords
  cached-parameter:
    match:
      keyword: 'cached'
    name: storage.modifier.cached-parameter.qlra

  extensional:
    match:
      keyword: 'extensional'
    name: storage.modifier.extensional.qlra

  unique:
    match:
      keyword: 'unique'
    name: storage.modifier.unique.qlra

  type-annotation-keyword:
    patterns:
    - include: '#cached-parameter'
    - include: '#extensional'
    - include: '#unique'

# Type keywords
  bool:
    match:
      keyword: 'bool'
    name: keyword.type.bool.qlra

  date:
    match:
      keyword: 'date'
    name: keyword.type.date.qlra
  
  float:
    match:
      keyword: 'float'
    name: keyword.type.float.qlra
  
  int:
    match:
      keyword: 'int'
    name: keyword.type.int.qlra
  
  numbered-tuple:
    match:
      keyword: 'numbered_tuple'
    name: keyword.type.numbered-tuple.qlra
  
  string:
    match:
      keyword: 'string'
    name: keyword.type.string.qlra
  
  type-keyword:
    patterns:
    - include: '#bool'
    - include: '#date'
    - include: '#float'
    - include: '#int'
    - include: '#numbered-tuple'
    - include: '#string'

# Operation keywords
  aggregate:
    match:
      keyword: 'AGGREGATE'
    name: keyword.other.aggregate.qlra

  and:
    match:
      keyword: 'AND'
    name: keyword.other.and.qlra

  as:
    match:
      keyword: 'AS'
    name: keyword.other.as.qlra

  asc:
    match:
      keyword: 'ASC'
    name: keyword.other.asc.qlra

  cartesian:
    match:
      keyword: 'CARTESIAN'
    name: keyword.other.cartesian.qlra

  constant:
    match:
      keyword: 'CONSTANT'
    name: keyword.other.constant.qlra

  count:
    match:
      keyword: 'COUNT'
    name: keyword.other.count.qlra
  
  dedup:
    match:
      keyword: 'DEDUP'
    name: keyword.other.dedup.qlra

  desc:
    match:
      keyword: 'DESC'
    name: keyword.other.desc.qlra

  evaluate:
    match:
      keyword: 'EVALUATE'
    name: keyword.other.evaluate.qlra

  fields:
    match:
      keyword: 'FIELDS'
    name: keyword.other.fields.qlra

  first:
    match:
      keyword: 'FIRST'
    name: keyword.other.first.qlra

  higher-order:
    match:
      keyword: 'HIGHER-ORDER'
    name: keyword.other.higher-order.qlra

  in:
    match:
      keyword: 'IN'
    name: keyword.other.in.qlra
  
  invoke:
    match:
      keyword: 'INVOKE'
    name: keyword.other.invoke.qlra

  join:
    match:
      keyword: 'JOIN'
    name: keyword.other.join.qlra

  layer:
    match:
      keyword: 'LAYER'
    name: keyword.other.layer.qlra

  load:
    match:
      keyword: 'LOAD'
    name: keyword.other.load.qlra

  matches-constant:
    match:
      keyword: 'matches_constant'
    name: keyword.other.matches-constant.qlra

  materialize:
    match:
      keyword: 'MATERIALIZE'
    name: keyword.other.materialize.qlra

  max:
    match:
      keyword: 'MAX'
    name: keyword.other.max.qlra

  min:
    match:
      keyword: 'MIN'
    name: keyword.other.min.qlra
  
  nonrecursive:
    match:
      keyword: 'NONRECURSIVE'
    name: keyword.other.nonrecursive.qlra
  
  not:
    match:
      keyword: 'NOT'
    name: keyword.other.not.qlra

  on:
    match:
      keyword: 'ON'
    name: keyword.other.on.qlra

  output:
    match:
      keyword: 'OUTPUT'
    name: keyword.other.output.qlra

  primitive:
    match:
      keyword: 'PRIMITIVE'
    name: keyword.other.primitive.qlra

  product:
    match:
      keyword: 'PRODUCT'
    name: keyword.other.product.qlra

  rank:
    match:
      keyword: 'RANK'
    name: keyword.other.rank.qlra

  rec:
    match:
      keyword: 'rec'
    name: keyword.other.rec.qlra

  recursive:
    match:
      keyword: 'RECURSIVE'
    name: keyword.other.recursive.qlra
  
  relation:
    match:
      keyword: 'RELATION'
    name: keyword.other.relation.qlra

  relations:
    match:
      keyword: 'RELATIONS'
    name: keyword.other.relations.qlra

  results:
    match:
      keyword: 'RESULTS'
    name: keyword.other.results.qlra

  return:
    match:
      keyword: 'return'
    name: keyword.control.flow.return.qlra

  scan:
    match:
      keyword: 'SCAN'
    name: keyword.other.scan.qlra

  select:
    match:
      keyword: 'SELECT'
    name: keyword.other.select.qlra

  stream:
    match:
      keyword: 'STREAM'
    name: keyword.other.stream.qlra

  sum:
    match:
      keyword: 'SUM'
    name: keyword.other.sum.qlra

  with:
    match:
      keyword: 'WITH'
    name: keyword.other.with.qlra

  operation-keyword:
    patterns:
    - include: '#aggregate'
    - include: '#and'
    - include: '#as'
    - include: '#asc'
    - include: '#cartesian'
    - include: '#constant'
    - include: '#count'
    - include: '#dedup'
    - include: '#desc'
    - include: '#evaluate'
    - include: '#fields'
    - include: '#first'
    - include: '#higher-order'
    - include: '#in'
    - include: '#invoke'
    - include: '#join'
    - include: '#layer'
    - include: '#load'
    - include: '#matches-constant'
    - include: '#materialize'
    - include: '#max'
    - include: '#min'
    - include: '#nonrecursive'
    - include: '#not'
    - include: '#on'
    - include: '#output'
    - include: '#primitive'
    - include: '#product'
    - include: '#rank'
    - include: '#rec'
    - include: '#recursive'
    - include: '#relation'
    - include: '#relations'
    - include: '#results'
    - include: '#return'
    - include: '#scan'
    - include: '#select'
    - include: '#stream'
    - include: '#sum'
    - include: '#with'

  local-variable:
    match: '(?#id)'
    name: entity.name.variable.local.qlra

  end-of-instruction:
    match: '(?=\{ | return\b)'

  instruction-lhs:
    begin: '(?=\{)'
    end: '(?==)'
    name: meta.block.instruction-lhs.qlra
    patterns:
    - include: '#natural-number'
    - include: '#open-brace'
    - include: '#close-brace'
    - include: '#local-variable'

  braced-tuple-op:
    beginPattern: '#open-brace'
    endPattern: '#close-brace'
    name: meta.block.braced-tuple-op.qlra

  non-braced-tuple-op:
    begin: '(?!\s | \{)'
    end: '(?#end-of-instruction)'
    patterns:
    - include: '#comma'
    - include: '#expr'

  tuple-op:
    patterns:
    - include: '#braced-tuple-op'
    - include: '#non-braced-tuple-op'

  operand-as-clause:
    beginPattern: '#as'
    endPattern: '#local-variable'
    name: meta.block.operand-as-clause.qlra

  operand:
    beginPattern: '#id'
    end: '(?!(?#as))'
    name: meta.block.operand.qlra
    patterns:
    - include: '#operand-as-clause'

  scan-output-clause:
    beginPattern: '#output'
    end: '(?#end-of-instruction) | (?<})'
    name: meta.block.scan-output-clause.qlra
    patterns:
    - include: '#fields'
    - include: '#tuple-op'

  scan-instruction:
    beginPattern: '#scan'
    end: '(?#end-of-instruction)'
    patterns:
    - include: '#operand'
    - include: '#scan-output-clause'
  
  union-instruction:
    beginPattern: '#operand'
    endPattern: '#operand'
    patterns:
    - include: '#union'

  instruction-rhs:
    beginPattern: '#equals'
    end: '(?#end-of-instruction)'
    name: meta.block.instruction-rhs.qlra
    patterns:
    - include: '#scan-instruction'
    - include: '#union-instruction'
