---
# This file is transformed into the equivalent JSON TextMate grammar, with the following additional
# features available:
#
# The `regexOptions` Property
# A top-level property named `regexOptions` may be defined with a string value. This string
# represents the set of regular expression options to apply to all regular expressions throughout
# the file.
#
# Macros
# The `macros` element defines a map of macro names to replacement text. When a `match`, `begin`, or
# `end` property has a value that is a single-key map, the value is replaced with the value of the
# macro named by the key, with any use of `(?#)` in the macro text replaced with the text of the
# value of the key, surrounded by a non-capturing group (`(?:)`). For example:
#
# The `beginPattern` and `endPattern` Properties
# A rule can have a `beginPattern` or `endPattern` property whose value is a reference to another
# rule (e.g. `#other-rule`). The `beginPattern` property is replaced as follows:
#
# my-rule:
#   beginPattern: '#other-rule'
#
# would be transformed to
#
# my-rule:
#   begin: '(?#other-rule)'
#   beginCaptures:
#     '0':
#       patterns:
#       - include: '#other-rule'
#
# An `endPattern` property is transformed similary.
#
# macros:
#   repeat: '(?#)*'
# repository:
#   multi-letter:
#     match:
#       repeat: '[A-Za-z]'
#     name: scope.multi-letter
# 
# would be transformed to
#
# repository:
#   multi-letter:
#     match: '(?:[A-Za-z])*'
#     name: scope.multi-letter
#
# Reference Expansion
# Any comment of the form `(?#ref-id)` in a `match`, `begin`, or `end` property will be replaced
# with the match text of the rule named "ref-id". If the rule named "ref-id" consists of just a
# `patterns` property with a list of `include` directives, the replacement pattern is the
# disjunction of the match patterns of all of the included rules.

name: QLRA
scopeName: source.qlra
fileTypes: [qlra]
uuid: DAFF8588-F676-4AC5-9CBE-9BC4086B03EF
regexOptions: 'x' # Ignore pattern whitespace

# Macros are parameterized patterns that can be used as a match elsewhere in the file.
# To use a macro, replace the string for a `match`, `begin`, or `end` property with a single-element
# map whose key is the name of the macro to invoke, and whose value is a string to be substituted for
# any usage of `(?#)` in the macro pattern definition.
macros:
  keyword: '\b(?#)(?#end-of-id)'

patterns:
  - include: '#comment'
  - include: '#literal'
  - include: '#constant-clause'
  - include: '#evaluation-keyword'
  - include: '#type-keyword'
  - include: '#operation-keyword'
  - include: '#relation-annotation-keyword'
  - include: '#operator-or-punctuation'
  - include: '#register'
  - include: '#temp-variable'
  - include: '#relation-with-parameters'
  - include: '#relation-id'

repository:
  # A character that can appear somewhere in an identifier.
  id-letter:
    match: '[0-9A-Za-z_]'

  # A character that can appear somewhere in a relation ID (include the `::` and `#` separators)
  relation-id-letter:
    match: '(?#id-letter)|[:\#@]'

  # Matches a position containing a non-identifier character. Used to ensure we do not match partial
  # identifiers/keywords in other rules.
  end-of-id:
    match: '(?!(?#id-letter))'

  simple-id:
    match: '@?(?#simple-id-no-at)'
  
  simple-id-no-at:
    match: '[A-Za-z](?#id-letter)* (?#end-of-id)'

  parameter-id:
    match: '[A-Za-z](?:(?#id-letter)|\#)* (?#end-of-id)'

  decoration-prefix:
    match: '(branch|dom|num|project)(?=\#)'
    name: storage.modifier.project.qlra

  staged-ext-suffix:
    match: '(@)(staged_ext)'
    captures:
      '1':
        name: punctuation.separator.at.qlra
      '2':
        name: storage.modifier.staged-ext.qlra

  decoration-suffix:
    match: '(?:(\#))((?#simple-id-no-at))'
    captures:
      '1':
        name: punctuation.separator.hash.qlra
      '2':
        name: storage.modifier.decorator.qlra

  relation-id:
    begin: '(?=(?#simple-id))'
    end: '(?!(?#relation-id-letter))'
    name: meta.block.relation-id.qlra
    patterns:
    - include: '#decoration-prefix'
    - include: '#hash'
    - include: '#relation-id-without-prefix'

  relation-id-without-prefix:
    begin: '(?=(?#simple-id))'
    end: '(?!(?#relation-id-letter))'
    name: meta.block.relation-id.qlra
    patterns:
    - include: '#staged-ext-suffix'
    - match: '(?#simple-id)'
      name: entity.name.function.qlra
    - include: '#coloncolon'
    - include: '#decoration-suffix'
    - include: '#hash'

  register:
    match: '\b r[0-9]+ (?#end-of-id)'
    name: entity.name.variable.local.register.qlra

  temp-variable:
    match: '(?:[A-Z]|agg) (?#end-of-id)'
    name: entity.name.variable.local.temp.qlra

  comment:
    begin: '\[\[\['
    beginCaptures:
      '0':
        name: punctuation.definition.comment.qlra
    end: ']]]|$'
    endCaptures:
      '0':
        name: punctuation.definition.comment.qlra
    name: comment.block.qlra

  # Literals
  integer-literal:
    match: '[0-9]+(?![0-9])'
    name: constant.numeric.decimal.qlra

  string-literal:
    begin: '"'
    beginCaptures:
      '0':
        name: punctuation.definition.string.begin.qlra
    end: '"|$' # Guard against unterminated strings
    endCaptures:
      '0':
        name: punctuation.definition.string.end.qlra
    name: string.quoted.double.qlra
    patterns:
      - match: '\\.'
        name: constant.character.escape.qlra

  literal:
    patterns:
    - include: '#integer-literal'
    - include: '#string-literal'

  # Operators and punctuation
  open-brace:
    match: '\{'
    name: punctuation.curlybrace.open.ql

  close-brace:
    match: '\}'
    name: punctuation.curlybrace.close.ql

  open-bracket:
    match: '\['
    name: punctuation.squarebracket.open.qlra

  close-bracket:
    match: '\]'
    name: punctuation.squarebracket.close.qlra

  open-paren:
    match: '\('
    name: punctuation.parenthesis.open.qlra

  close-paren:
    match: '\)'
    name: punctuation.parenthesis.close.qlra

  arithmetic-operator:
    match: '\+ | - | \* | / | %'
    name: keyword.operator.arithmetic.qlra

  colon:
    match: ':'
    name: punctuation.separator.colon.qlra
  
  coloncolon:
    match: '::'
    name: punctuation.separator.coloncolon.qlra
  
  comma:
    match: ','
    name: punctuation.separator.comma.qlra
  
  concatenation:
    match: '\+\+'
    name: keyword.operator.arithmetic.qlra

  define:
    match: ':-'
    name: punctuation.separator.define.qlra

  dot:
    match: '\.'
    name: punctuation.separator.dot.qlra

  equals:
    match: '='
    name: punctuation.separator.equals.qlra

  hash:
    match: '\#'
    name: punctuation.separator.hash.qlra

  relational-operator:
    match: '<= | < | >= | >'
    name: keyword.operator.relational.qlra

  semicolon:
    match: ';'
    name: punctuation.separator.statement.qlra
  
  stage-end:
    match: '========'
    name: punctuation.separator.stage-end.qlra

  union:
    match: '\\/'
    name: punctuation.operator.union.qlra

  operator-or-punctuation:
    patterns:
    - include: '#coloncolon' # Must precede colon
    - include: '#concatenation' # Must precede arithmetic-operator
    - include: '#define' # Must precede colon
    - include: '#stage-end' # Must precede equals
    - include: '#open-brace'
    - include: '#close-brace'
    - include: '#open-bracket'
    - include: '#close-bracket'
    - include: '#open-paren'
    - include: '#close-paren'
    - include: '#arithmetic-operator'
    - include: '#colon'
    - include: '#comma'
    - include: '#dot'
    - include: '#equals'
    - include: '#hash'
    - include: '#relational-operator'
    - include: '#semicolon'
    - include: '#union'

# Relation annotation keywords
  cached:
    match:
      keyword: 'CACHED'
    name: storage.modifier.cached.qlra
  
  computed:
    match:
      keyword: 'COMPUTED'
    name: storage.modifier.computed.qlra

  synthetic:
    match:
      keyword: 'SYNTHETIC'
    name: storage.modifier.synthetic.qlra

  relation-annotation-keyword:
    patterns:
    - include: '#cached'
    - include: '#computed'
    - include: '#synthetic'

# Type annotation keywords
  extensional:
    match:
      keyword: 'extensional'
    name: storage.modifier.extensional.qlra

  unique:
    match:
      keyword: 'unique'
    name: storage.modifier.unique.qlra

  type-annotation-keyword:
    patterns:
    - include: '#extensional'
    - include: '#unique'

# Type keywords
  bool:
    match:
      keyword: 'bool'
    name: keyword.type.bool.qlra

  date:
    match:
      keyword: 'date'
    name: keyword.type.date.qlra
  
  float:
    match:
      keyword: 'float'
    name: keyword.type.float.qlra
  
  int:
    match:
      keyword: 'int'
    name: keyword.type.int.qlra
  
  numbered-tuple:
    match:
      keyword: 'numbered_tuple'
    name: keyword.type.numbered-tuple.qlra
  
  string:
    match:
      keyword: 'string'
    name: keyword.type.string.qlra
  
  type-keyword:
    patterns:
    - include: '#bool'
    - include: '#date'
    - include: '#float'
    - include: '#int'
    - include: '#numbered-tuple'
    - include: '#string'

# Evaluation keywords
  evaluate:
    match:
      keyword: 'EVALUATE'
    name: keyword.other.evaluate.qlra
  
  in:
    match:
      keyword: 'IN'
    name: keyword.other.in.qlra
  
  layer:
    match:
      keyword: 'LAYER'
    name: keyword.other.layer.qlra

  load:
    match:
      keyword: 'LOAD'
    name: keyword.other.load.qlra

  nonrecursive:
    match:
      keyword: 'NONRECURSIVE'
    name: keyword.other.nonrecursive.qlra
  
  rec:
    match:
      keyword: 'rec'
    name: keyword.other.rec.qlra

  recursive:
    match:
      keyword: 'RECURSIVE'
    name: keyword.other.recursive.qlra
  
  relation:
    match:
      keyword: 'RELATION'
    name: keyword.other.relation.qlra

  relations:
    match:
      keyword: 'RELATIONS'
    name: keyword.other.relations.qlra

  results:
    match:
      keyword: 'RESULTS'
    name: keyword.other.results.qlra

  evaluation-keyword:
    patterns:
    - include: '#evaluate'
    - include: '#in'
    - include: '#layer'
    - include: '#load'
    - include: '#nonrecursive'
    - include: '#rec'
    - include: '#recursive'
    - include: '#relation'
    - include: '#relations'
    - include: '#results'

# Operation keywords
  aggregate:
    match:
      keyword: 'AGGREGATE'
    name: keyword.other.aggregate.qlra

  and:
    match:
      keyword: 'AND'
    name: keyword.other.and.qlra

  as:
    match:
      keyword: 'AS'
    name: keyword.other.as.qlra

  asc:
    match:
      keyword: 'ASC'
    name: keyword.other.asc.qlra

  cartesian:
    match:
      keyword: 'CARTESIAN'
    name: keyword.other.cartesian.qlra

  constant:
    match:
      keyword: 'CONSTANT'
    name: keyword.other.constant.qlra

  count:
    match:
      keyword: 'COUNT'
    name: keyword.other.count.qlra
  
  dedup:
    match:
      keyword: 'DEDUP'
    name: keyword.other.dedup.qlra

  first:
    match:
      keyword: 'FIRST'
    name: keyword.other.first.qlra

  join:
    match:
      keyword: 'JOIN'
    name: keyword.other.join.qlra

  matches-constant:
    match:
      keyword: 'matches_constant'
    name: keyword.other.matches-constant.qlra

  max:
    match:
      keyword: 'MAX'
    name: keyword.other.max.qlra

  min:
    match:
      keyword: 'MIN'
    name: keyword.other.min.qlra
  
  not:
    match:
      keyword: 'NOT'
    name: keyword.other.not.qlra

  on:
    match:
      keyword: 'ON'
    name: keyword.other.on.qlra

  output:
    match:
      keyword: 'OUTPUT'
    name: keyword.other.output.qlra

  primitive:
    match:
      keyword: 'PRIMITIVE'
    name: keyword.other.primitive.qlra

  product:
    match:
      keyword: 'PRODUCT'
    name: keyword.other.product.qlra

  rank:
    match:
      keyword: 'RANK'
    name: keyword.other.rank.qlra

  return:
    match:
      keyword: 'return'
    name: keyword.control.flow.return.qlra

  scan:
    match:
      keyword: 'SCAN'
    name: keyword.other.scan.qlra

  select:
    match:
      keyword: 'SELECT'
    name: keyword.other.select.qlra

  stream:
    match:
      keyword: 'STREAM'
    name: keyword.other.stream.qlra

  sum:
    match:
      keyword: 'SUM'
    name: keyword.other.sum.qlra

  with:
    match:
      keyword: 'WITH'
    name: keyword.other.with.qlra

  operation-keyword:
    patterns:
    - include: '#aggregate'
    - include: '#and'
    - include: '#as'
    - include: '#asc'
    - include: '#cartesian'
    - include: '#constant'
    - include: '#count'
    - include: '#dedup'
    - include: '#first'
    - include: '#join'
    - include: '#matches-constant'
    - include: '#max'
    - include: '#min'
    - include: '#not'
    - include: '#on'
    - include: '#output'
    - include: '#primitive'
    - include: '#product'
    - include: '#rank'
    - include: '#return'
    - include: '#scan'
    - include: '#select'
    - include: '#stream'
    - include: '#sum'
    - include: '#with'

  relation-with-parameters:
    begin: '(?=(?#relation-id-letter)+\()'
    end: '(?<=\))'
    name: meta.block.relation-with-parameters.qlra
    patterns:
    - include: '#relation-id'
    - include: '#parameter-list'

  parameter-list:
    beginPattern: '#open-paren'
    endPattern: '#close-paren'
    name: meta.block.parameter-list.qlra
    patterns:
      # A simple-id followed by a `,` or a `)` is a parameter name.
    - match: '(?#parameter-id)(?=\s*(?:,|\)))'
      name: variable.parameter.qlra
    - include: '#type-keyword'
    - include: '#type-annotation-keyword'
    - include: '#comma'

  constant-clause:
    beginPattern: '#constant'
    end: '(?<=\))'
    name: meta.block.constant-clause.qlra
    patterns:
    - include: '#parameter-list'
